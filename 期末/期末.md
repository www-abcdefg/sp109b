# 期末專案 C1-c4編譯器
## 此專案參考陳鍾誠老師的專案(C1-c4)並加上自己對此程式的理解以及對編譯器的理解
## 編譯器
* 編譯器的主要工作流程
    * 原始碼 → 預處理器 → 編譯器 → 組譯程式 → 目的碼 → 連結器 → 執行檔
* 編譯器的基本功能
![picture](https://github.com/www-abcdefg/sp109b/blob/main/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD.png)
* 編譯器有分為六個大階段
![picture](https://github.com/www-abcdefg/sp109b/blob/main/pic/%E5%85%AD%E5%A4%A7%E6%AD%A5%E9%A9%9F.png)
## 編譯器的編寫分為 3 個步驟
* 詞法分析器，用於將字串轉化成內部的表示結構。
* 語法分析器，將詞法分析得到的標記流生成一棵語法樹。
* 目的碼的生成，將語法樹轉化成目的碼。
## 編譯器的框架
```
next() 用於詞法分析，獲取下一個標記，它將自動忽略空白字元。
program() 語法分析的入口，分析整個 C 語言程式。
expression(level) 用於解析一個表示式。
eval() 虛擬機器的入口，用於解釋目的碼。
```
## 編譯器主要關注內容
* 程式碼段、資料段以及處理函式呼叫相關的資料。
* 因為我們的編譯器並不支援初始化變數，因此我們不需要未初始化資料段。
* 理論上我們的虛擬器需要維護自己的堆用於記憶體分配，但實際實現上較為複雜且與編譯無關，故我們引入一個指令MSET，使我們能直接使用編譯器中的記憶體。
* int型程式碼段中存放如指標/記憶體地址的資料，應該作為無符號，char * 型 資料段由於只存放字串。
* 在main函式中加入初始化程式碼，為其分配記憶體。
## 暫存器
* PC 程式計數器，它存放的是一個記憶體地址，該地址中存放著 下一條 要執行的計算機指令。
    * main 函式中加入初始化程式碼，注意的是PC在初始應指向目的碼中的main函式
* SP 指標暫存器，永遠指向當前的棧頂。注意的是由於棧(處理函式呼叫相關的資料)是位於高地址並向低地址增長的，所以入棧時 SP 的值減小。
* BP 基址指標。也是用於指向棧的某些位置，在呼叫函式時會使用到它。
* AX 通用暫存器，我們的虛擬機器中，它用於存放一條指令執行後的結果。
## MOV
* 將資料放進暫存器或記憶體地址
*  MOV 指令有兩個引數
    * 源地址和目標地址：MOV dest, source 
* MOV 指令拆分成 5 個指令
    * IMM num 將 num 放入暫存器 ax 中。
    * LC 將對應地址中的"字元"載入 ax 中，要求 ax 中存放地址。
    * LI 將對應地址中的"整數"載入 ax 中，要求 ax 中存放地址。
    * SC 將 ax 中的資料作為字元存放入地址中，要求棧頂存放地址。
    * SI 將 ax 中的資料作為整數存放入地址中，要求棧頂存放地址。
* *sp++ 的作用是退棧，相當於 POP 操作。
## SI/SC 指令中，地址存放在棧中，而 LI/LC 中，地址存放在ax 中？
* 預設計算的結果是存放在 ax 中的，而地址通常是需要通過計算獲得，所以執行 LI/LC 時直接從 ax 取值會更高效。
* PUSH 指令只能將 ax 的值放到棧上，而不能以值作為引數。
## JMP
* JMP addr 是跳轉指令，無條件地將當前的 PC 暫存器設定為指定的 addr
    * pc 暫存器指向的是 下一條 指令。所以此時它存放的是 JMP 指令的引數。
## JZ/JNZ
* 判斷相關的指令，即結果（ax）為零或不為零情況下的跳轉。
## 子函式呼叫
* 引入的命令有 CALL, ENT, ADJ 及LEV。
    * CALL 的作用是跳轉到地址為 <addr> 的子函式，RET 則用於從子函式中返回。
        * 為什麼不能直接使用 JMP 指令呢?
            * 當我們從子函式中返回時，程式需要回到跳轉之前的地方繼續執行，這就需要事先將這個位置資訊儲存起來。
            * 子函式要返回時，就需要獲取並恢復這個資訊。因此實際中我們將 PC 儲存在棧中。
    * 用 LEV 指令來代替RET
* C 語言的呼叫標準
    * 由呼叫者將引數入棧。
    * 呼叫結束時，由呼叫者將引數出棧。
    * 引數逆序入棧。
## 詞法分析器
* 用於對源碼字符串做預處理，以減少語法分析器的複雜程度。
* 詞法分析器以源碼字符串為輸入，輸出為標記流（token stream）
    * 每个標記通常包括： (token, token value) 即標記本身和標記的值
        * ex :源代碼中若包含一個數字 '998' 則詞法分析器將輸出 (Number, 998)，即（數字，998）
* 詞法分析器與編譯器的差別
    * 編譯器是以標記流為輸入，輸出匯編代碼，而詞法分析器則是以源碼字符串為輸入，輸出為標記流。
* while 循環的作用就是跳過些我們不識別的字符，我們同時還用它來處理空白字符
* 換行符
    * 每次遇到換行符，我们需要將當前的行號加一
## 編寫語法分析器(兩種方法)
* 自頂向下
    * 自頂向下是從起始非終結符開始，不斷地對非終結符進行分解，直到匹配輸入的終結符，又稱遞迴下降。
* 自底自上
    * 自底向上是不斷地將終結符進行合併，直到合併成起始的非終結符。
        * 尖括號 <> 括起來的就稱作 非終結符 ，因為它們可以用 ::= 右側的式子代替
        * 沒有出現在::=左邊的就稱作 終結符 ，一般終結符對應於詞法分析器輸出的標記。
## 語法分析
* 變數定義
    * 向前看標記
        *  if (token == xxx) 語句就是用來向前檢視標記以確定使用哪一個產生式 ex:遇到 enum 我們就知道是需要解析列舉型別
* 函式定義
* 語句
```
1.if (...) <statement> [else <statement>]
if的作用是跳轉，跟據條件表示式決定跳轉的位置
2.while (...) <statement>
3.{ <statement> }
4.return xxx;
return 唯一特殊的地方是：一旦遇到了 return ，則意味著函式要退出，所以需要生成彙編程式碼 LEV 來表示退出。
5.<empty statement>;
6.expression;
```
* 表示式
    * 編譯器的最後一部分，也是將各種語言要素的組合
    * 表示式須解決問題
        * 運算子的優先順序問題
        * 如何將表示式編譯成目的碼
    * 一元運算子
        * 一元運算子的優先順序總是高於多元運算子
    * 常量
        * p="first line" "second line"; 跨行的字串拼接，它相當於 p="first linesecond line";
    * 變數與函式呼叫
        * 如果變數的值與函式的呼叫都是以 Id 標記開頭的，就將它們放在一起處理。
## C4編譯器介紹 
* C4 是一個小型 C 語言編譯器，它具備完整的詞法分析、語法分析、簡單的語義檢查、代碼生成、運行時環境（即虛擬機）。
* 它與常見的C編譯器不同的地方在於，它把C語言源程序編譯成字節碼（bytecode），然後在一個精簡的虛擬機中解釋執行。
## C4語法介紹 
* [C4 編譯器的語法](https://gitlab.com/ccc109/sp/-/blob/master/C1-c4/C4%E7%B7%A8%E8%AD%AF%E5%99%A8%E7%9A%84%E8%AA%9E%E6%B3%95.md)
## C4 code
* c4.c
    * [老師code](https://gitlab.com/ccc109/sp/-/blob/master/C1-c4/c4.c)
    * 以下為我對此編譯器的看法
    * [我對此code的看法](https://github.com/www-abcdefg/sp109b/blob/main/%E6%9C%9F%E6%9C%AB/C1-c4/c4.c)
* 結果
![](https://github.com/www-abcdefg/sp109b/blob/main/%E6%9C%9F%E6%9C%AB/pic.md)


## 參考資料
* [手把手教你做一個 C 語言編譯器（0）：前言](https://www.itread01.com/content/1546074209.html)
* [手把手教你做一個 C 語言編譯器（1）：設計](https://www.itread01.com/content/1546074380.html)
* [手把手教你做一個 C 語言編譯器（2）：虛擬機器](https://www.itread01.com/content/1546071510.html)
* [手把手教你构建 C 语言编译器（3）- 词法分析器](https://lotabout.me/2015/write-a-C-interpreter-3/)
* [手把手教你做一個 C 語言編譯器（4）：遞迴下降](https://www.itread01.com/content/1546073118.html)
* [手把手教你做一個 C 語言編譯器（5）：變數定義](https://www.itread01.com/content/1546075093.html)
* [手把手教你做一個 C 語言編譯器（6）：函式定義 ](https://www.itread01.com/content/1546072214.html)
* [手把手教你做一個 C 語言編譯器（7）：語句](https://www.itread01.com/content/1545510448.html)
* [手把手教你做一個 C 語言編譯器（8）：表示式](https://www.itread01.com/content/1545510446.html)
* [手把手教你做一個 C 語言編譯器（9）：總結](https://www.itread01.com/content/1545510449.html)
* [陳鍾誠老師 sp/C1-c4](https://gitlab.com/ccc109/sp/-/tree/master/C1-c4)
* [c4](https://github.com/comzyh/c4)

