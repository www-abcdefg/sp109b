# 期末專案 C1-c4編譯器
## 此專案參考陳鍾誠老師的專案(C1-c4)並加上自己對此程式的理解以及對編譯器的理解
## 編譯器
* 編譯器的主要工作流程
    * 原始碼 → 預處理器 → 編譯器 → 組譯程式 → 目的碼 → 連結器 → 執行檔
* 編譯器的基本功能
![picture](https://github.com/www-abcdefg/sp109b/blob/main/pic/%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD.png)
* 編譯器有分為六個大階段
![picture](https://github.com/www-abcdefg/sp109b/blob/main/pic/%E5%85%AD%E5%A4%A7%E6%AD%A5%E9%A9%9F.png)
## 為何要學編譯原理
<details>
* 學會編譯原理，就能寫出更加高效的程式碼。
</details>
## 編譯器的編寫分為 3 個步驟
* 詞法分析器，用於將字串轉化成內部的表示結構。
* 語法分析器，將詞法分析得到的標記流生成一棵語法樹。
* 目的碼的生成，將語法樹轉化成目的碼。
## 編譯器的框架
```
next() 用於詞法分析，獲取下一個標記，它將自動忽略空白字元。
program() 語法分析的入口，分析整個 C 語言程式。
expression(level) 用於解析一個表示式。
eval() 虛擬機器的入口，用於解釋目的碼。
```
## 編譯器主要關注內容
* 程式碼段、資料段以及處理函式呼叫相關的資料。
* 因為我們的編譯器並不支援初始化變數，因此我們不需要未初始化資料段。
* 理論上我們的虛擬器需要維護自己的堆用於記憶體分配，但實際實現上較為複雜且與編譯無關，故我們引入一個指令MSET，使我們能直接使用編譯器中的記憶體。
* int型程式碼段中存放如指標/記憶體地址的資料，應該作為無符號，char * 型 資料段由於只存放字串。
* 在main函式中加入初始化程式碼，為其分配記憶體。
## 暫存器
* PC 程式計數器，它存放的是一個記憶體地址，該地址中存放著 下一條 要執行的計算機指令。
    * main 函式中加入初始化程式碼，注意的是PC在初始應指向目的碼中的main函式
* SP 指標暫存器，永遠指向當前的棧頂。注意的是由於棧(處理函式呼叫相關的資料)是位於高地址並向低地址增長的，所以入棧時 SP 的值減小。
* BP 基址指標。也是用於指向棧的某些位置，在呼叫函式時會使用到它。
* AX 通用暫存器，我們的虛擬機器中，它用於存放一條指令執行後的結果。
## 指令集
* CPU 能識別的命令的集合
## MOV
* 將資料放進暫存器或記憶體地址
*  MOV 指令有兩個引數
    * 源地址和目標地址：MOV dest, source 
* MOV 指令拆分成 5 個指令
    * IMM num 將 num 放入暫存器 ax 中。
    * LC 將對應地址中的"字元"載入 ax 中，要求 ax 中存放地址。
    * LI 將對應地址中的"整數"載入 ax 中，要求 ax 中存放地址。
    * SC 將 ax 中的資料作為字元存放入地址中，要求棧頂存放地址。
    * SI 將 ax 中的資料作為整數存放入地址中，要求棧頂存放地址。
* *sp++ 的作用是退棧，相當於 POP 操作。
## 為什麼 SI/SC 指令中，地址存放在棧中，而 LI/LC 中，地址存放在ax 中？
* 預設計算的結果是存放在 ax 中的，而地址通常是需要通過計算獲得，所以執行 LI/LC 時直接從 ax 取值會更高效。
* PUSH 指令只能將 ax 的值放到棧上，而不能以值作為引數。
## JMP
* JMP addr 是跳轉指令，無條件地將當前的 PC 暫存器設定為指定的 addr
    * pc 暫存器指向的是 下一條 指令。所以此時它存放的是 JMP 指令的引數。
## JZ/JNZ
* 判斷相關的指令，即結果（ax）為零或不為零情況下的跳轉。
## 子函式呼叫
* 引入的命令有 CALL, ENT, ADJ 及LEV。
    * CALL 的作用是跳轉到地址為 <addr> 的子函式，RET 則用於從子函式中返回。
        * 為什麼不能直接使用 JMP 指令呢?
            * 當我們從子函式中返回時，程式需要回到跳轉之前的地方繼續執行，這就需要事先將這個位置資訊儲存起來。
            * 子函式要返回時，就需要獲取並恢復這個資訊。因此實際中我們將 PC 儲存在棧中。
    * 用 LEV 指令來代替RET
* C 語言的呼叫標準
    * 由呼叫者將引數入棧。
    * 呼叫結束時，由呼叫者將引數出棧。
    * 引數逆序入棧。
## 詞法分析器
* 用於對源碼字符串做預處理，以減少語法分析器的複雜程度。
* 詞法分析器以源碼字符串為輸入，輸出為標記流（token stream）
    * 每个標記通常包括： (token, token value) 即標記本身和標記的值
        * ex :源代碼中若包含一個數字 '998' 則詞法分析器將輸出 (Number, 998)，即（數字，998）
* 詞法分析器與編譯器的差別
    * 編譯器是以標記流為輸入，輸出匯編代碼，而詞法分析器則是以源碼字符串為輸入，輸出為標記流。
* while 循環的作用就是跳過些我們不識別的字符，我們同時還用它來處理空白字符
* 換行符
    * 每次遇到換行符，我们需要將當前的行號加一
## 編寫語法分析器(兩種方法)
* 自頂向下
    * 自頂向下是從起始非終結符開始，不斷地對非終結符進行分解，直到匹配輸入的終結符，又稱遞迴下降。
* 自底自上
    * 自底向上是不斷地將終結符進行合併，直到合併成起始的非終結符。
        * 尖括號 <> 括起來的就稱作 非終結符 ，因為它們可以用 ::= 右側的式子代替
        * 沒有出現在::=左邊的就稱作 終結符 ，一般終結符對應於詞法分析器輸出的標記。
## 語法分析
* 變數定義
    * 向前看標記
        *  if (token == xxx) 語句就是用來向前檢視標記以確定使用哪一個產生式 ex:遇到 enum 我們就知道是需要解析列舉型別
* 函式定義
* 語句
```
1.if (...) <statement> [else <statement>]
if的作用是跳轉，跟據條件表示式決定跳轉的位置
2.while (...) <statement>
3.{ <statement> }
4.return xxx;
return 唯一特殊的地方是：一旦遇到了 return ，則意味著函式要退出，所以需要生成彙編程式碼 LEV 來表示退出。
5.<empty statement>;
6.expression;
```
expression; 
* 表示式
    * 編譯器的最後一部分，也是將各種語言要素的組合
    * 表示式須解決問題
        * 運算子的優先順序問題
        * 如何將表示式編譯成目的碼
    * 一元運算子
        * 一元運算子的優先順序總是高於多元運算子
    * 常量
        * p="first line" "second line"; 跨行的字串拼接，它相當於 p="first linesecond line";
    * 變數與函式呼叫
        * 如果變數的值與函式的呼叫都是以 Id 標記開頭的，就將它們放在一起處理。
## C4編譯器介紹 
* C4 是一個小型 C 語言編譯器，它具備完整的詞法分析、語法分析、簡單的語義檢查、代碼生成、運行時環境（即虛擬機）。
* 它與常見的C編譯器不同的地方在於，它把C語言源程序編譯成字節碼（bytecode），然後在一個精簡的虛擬機中解釋執行。
## C4語法介紹 
* [C4 編譯器的語法](https://gitlab.com/ccc109/sp/-/blob/master/C1-c4/C4%E7%B7%A8%E8%AD%AF%E5%99%A8%E7%9A%84%E8%AA%9E%E6%B3%95.md)
* C4 只支援《自我編譯》的那些語法，並非支援完整的 C 語言語法。
## 支援的語法
項目 | 語法
-----|-------------------
判斷 | if ... else
迴圈 | while (...)
區塊 | {...}
函數呼叫 | f()
函數定義 | int f(....)
傳回值 | return 
陣列存取 | a[i] 
數學運算 | +-*/%, ++, --, +=, -=, *=, /=, %=
位元運算 | &|^~
邏輯運算 |  ! && || 
列舉 | enum ...
運算式 | (a*3+5)/b 
指定 | x = (a*3+5)/b
取得大小 | sizeof
強制轉型 | (int*) ptr; (char) a;
基本型態 | int, char
指標 | *ptr 
遞迴 | int f(n) { ... return f(n-1) + f(n-2); }
陣列存取 | a[i]
## 沒有支援的語法
項目 | 語法
-----|-------------------
結構 | struct
設定初值 | int a=3; int arr = {1,2,3}
巨集 | #define LEN 100
宣告陣列 | int a[10];
## 忽略的語法
對於引入標頭檔， C4 會忽略這些指令，但是預設已經引入了像 printf 之類的函式庫。
項目 | 語法
-----|-------------------
引入標頭檔 | #include <stdio.h>
## C4 code
* c4.c
    * 以下為我對此編譯器的看法
    * [老師code](https://gitlab.com/ccc109/sp/-/blob/master/C1-c4/c4.c)
    * [我對此code的看法](https://github.com/www-abcdefg/sp109b/blob/main/%E6%9C%9F%E6%9C%AB/C1-c4/c4.c)
```
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <unistd.h>
#include <fcntl.h>
//此處引入標頭檔 C4會自動忽略並轉為類似printf等類函式庫

char *p, *lp, // 當前源代碼位置 (*:指標 p: 目前原始碼指標, lp: 上一行原始碼指標)
     *data;   // 資料段機器碼指標

int *e, *le,  // 發出代碼目前位置 (e: 目前機器碼指標, le: 上一行機器碼指標)
    *id,      // 目前解析出來的標識名稱(符) (id: 目前的 id)
    *sym,     // 簡單的標識列表 (符號表)
    tk,       // 當前標記(目前 token)
    ival,     // 當前標記值 (目前的 token 值)
    ty,       // 當前表示式型態 (目前的運算式型態)
    loc,      // 區域變數位移 (區域變數的位移)
    line,     // 目前行號 (目前行號)
    src,      // 印出原始碼和程序標誌 (印出原始碼)
    debug;    // 印出執行指令 (印出執行指令 -- 除錯模式)

// tokens and classes (運算符最後並按優先順序排列) (按優先權順序排列)
enum { // token(標記) : 0-127 直接用該字母表達， 128 以後用代號。
  Num = 128, Fun, Sys, Glo, Loc, Id,
  Char, Else, Enum, If, Int, Return, Sizeof, While,
  Assign, Cond, Lor, Lan, Or, Xor, And, Eq, Ne, Lt, Gt, Le, Ge, Shl, Shr, Add, Sub, Mul, Div, Mod, Inc, Dec, Brak
};

// opcodes (機器碼的 op)
// LEA : load local address 載入區域變數 
// IMM : load global address or immediate 載入全域變數或立即值 
// JMP : jump               躍躍指令  
// JSR : jump to subroutine 跳到副程式 
// BZ  : branch if zero     if (a==0) goto m[pc] 
// BNZ : branch if not zero if (a!=0) goto m[pc]   
// ENT : enter subroutine   進入副程式 
// ADJ : stack adjust       調整堆疊
// LEV : leave subroutine   離開副程式 
// LI  : load int           載入整數
// LC  : load char          載入字元 
// SI  : store int          儲存整數
// SC  : store char         儲存字元  
// PSH : push               推入堆疊   
// OR  : a = a OR pop       OR(|) pop 代表從堆疊中取出一個元素 
// XOR : a = a XOR pop      XOR(^)
// AND : a = a AND pop      AND(&)
// EQ : a = a EQ pop        EQ(==)
// NE : a = a NE pop        NE(!=)
// LT : a = a LT pop        LT(<)
// GT : a = a GT pop        GT(>)
// LE : a = a LE pop        LE(<=)
// GE : a = a GE pop        GE(>=)  
// SHL : a = a SHL pop      SHL(<<)
// SHR : a = a SHR pop      SHR(>>) 
// ADD : a = a ADD pop      ADD(+)
// SUB : a = a SUB pop      SUB(-)
// MUL : a = a MUL pop      MUL(*)
// DIV : a = a DIV pop      DIV(/)
// MOD : a = a MOD pop      MOD(%)
// EXIT : 終止離開 
enum { LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,
       OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,
       OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT };

// types (支援型態，只有 int, char, pointer)
enum { CHAR, INT, PTR };

// 因為沒有 struct，所以使用 offset 代替，例如 id[Tk] 代表 id.Tk (token), id[Hash] 代表 id.Hash, id[Name] 代表 id.Name, .....
// 標識符位移 (since we can't create an ident struct)
enum { Tk, Hash, Name, Class, Type, Val, HClass, HType, HVal, Idsz }; // HClass, HType, HVal 是暫存的備份

void next() // 詞彙解析 lexer
{
  char *pp;  // 用循環來忽略空白字符,不過不能被詞法分析器識別的字符都被認為是空白字符

  while (tk = *p) {
    ++p;
    if (tk == '\n') { // 換行
      if (src) {
        printf("%d: %.*s", line, p - lp, lp); // 印出該行 行號目前位置 上一行源代碼指標
        lp = p; // lp = p = 新一行的原始碼開頭
        while (le < e) { //  當上一行機器碼指標小於目前機器碼指標時 印出上一行的所有目的碼
          printf("%8.4s", &"LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,"
                           "OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,"
                           "OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,"[*++le * 5]);
          if (*le <= ADJ) printf(" %d\n", *++le); else printf("\n"); // LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ 有一個參數。
        }// 假如上一行機器碼指標小於等於調整堆疊 
      }
      ++line;
    }
    else if (tk == '#') { // 取得 #include <stdio.h> 引入標頭檔這類的一整行
      while (*p != 0 && *p != '\n') ++p;//當目前原始碼指標不等於零and不為空值
    }
    else if ((tk >= 'a' && tk <= 'z') || (tk >= 'A' && tk <= 'Z') || tk == '_') { // 取得變數名稱
      pp = p - 1;//因为有++p,pp回退一个字符,pp指向 [这个符號] 的首字母
      while ((*p >= 'a' && *p <= 'z') || (*p >= 'A' && *p <= 'Z') || (*p >= '0' && *p <= '9') || *p == '_')//目前原始碼指標(大於等於a and 小於等於z)or(大於等於A and 小於等於Z)or(大於等於0 and 小於等於9)or為空值
        tk = tk * 147 + *p++;  // 計算雜湊值
      tk = (tk << 6) + (p - pp); // 符號表的雜湊位址 ??
      id = sym;//  目前解析出來的名稱=列表
      while (id[Tk]) { // 檢查是否碰撞 ?
        if (tk == id[Hash] && !memcmp((char *)id[Name], pp, p - pp)) { tk = id[Tk]; return; } // 沒碰撞就傳回   tokenmemcmp(const void *str1, const void *str2, size_t n)) str1、str2 -- 這就是指針的內存塊。 n -- 這是要比較的字節數。
        id = id + Idsz; // 碰撞，前進到下一格。
      }
      id[Name] = (int)pp; // id.Name = ptr(變數名稱)
      id[Hash] = tk; // id.Hash = 雜湊值
      tk = id[Tk] = Id; // token = id.Tk = Id  token 類型為 identifier
      return;
    }
    else if (tk >= '0' && tk <= '9') { // 取得數字串
      if (ival = tk - '0') { while (*p >= '0' && *p <= '9') ival = ival * 10 + *p++ - '0'; } // 十進位
      else if (*p == 'x' || *p == 'X') { // 十六進位  「x」則代表十六進位（就如「O」代表八進位)
        while ((tk = *++p) && ((tk >= '0' && tk <= '9') || (tk >= 'a' && tk <= 'f') || (tk >= 'A' && tk <= 'F'))) // 16 進位
          ival = ival * 16 + (tk & 15) + (tk >= 'A' ? 9 : 0);
      }
      else { while (*p >= '0' && *p <= '7') ival = ival * 8 + *p++ - '0'; } // 八進位
      tk = Num; // token = Number
      return;
    }
    else if (tk == '/') {
      if (*p == '/') { // 註解
        ++p;
        while (*p != 0 && *p != '\n') ++p; // 略過註解
      }
      else { // 除法
        tk = Div;//當前標記為除
        return;
      }
    }
    else if (tk == '\'' || tk == '"') { // 字元或字串
      pp = data;//等於資料段
      while (*p != 0 && *p != tk) {//直到找到匹配的引號為止
        if ((ival = *p++) == '\\') {
          if ((ival = *p++) == 'n') ival = '\n'; // 處理 \n 的特殊情況('\n' 认为是'\n' 其他直接忽略'\')
        }
        if (tk == '"') *data++ = ival; // 把字串塞到資料段裏(如果是"則視為字符串，向資料段輸入字符)
      }
      ++p;
      if (tk == '"') ival = (int)pp; else tk = Num; // (若是字串) ? (ival = 字串 (在資料段中的) 指標) : (字元值) 
      //雙引號(")則ival指向data中字符串开始,單引號則視為数字
      return;
    } // 以下為運算元 =+-!<>|&^%*[?~, ++, --, !=, <=, >=, ||, &&, ~  ;{}()],:
    else if (tk == '=') { if (*p == '=') { ++p; tk = Eq; } else tk = Assign; return; }//等於,賦值
    else if (tk == '+') { if (*p == '+') { ++p; tk = Inc; } else tk = Add; return; }//加
    else if (tk == '-') { if (*p == '-') { ++p; tk = Dec; } else tk = Sub; return; }//減
    else if (tk == '!') { if (*p == '=') { ++p; tk = Ne; } return; }//不等於
    else if (tk == '<') { if (*p == '=') { ++p; tk = Le; } else if (*p == '<') { ++p; tk = Shl; } else tk = Lt; return; }//< ， <= ，<<
    else if (tk == '>') { if (*p == '=') { ++p; tk = Ge; } else if (*p == '>') { ++p; tk = Shr; } else tk = Gt; return; }//> ， >= ，>>
    else if (tk == '|') { if (*p == '|') { ++p; tk = Lor; } else tk = Or; return; }//或 
    else if (tk == '&') { if (*p == '&') { ++p; tk = Lan; } else tk = And; return; }//和
    else if (tk == '^') { tk = Xor; return; }
    else if (tk == '%') { tk = Mod; return; }
    else if (tk == '*') { tk = Mul; return; }
    else if (tk == '[') { tk = Brak; return; }
    else if (tk == '?') { tk = Cond; return; }
    else if (tk == '~' || tk == ';' || tk == '{' || tk == '}' || tk == '(' || tk == ')' || tk == ']' || tk == ',' || tk == ':') return;
  }
}

void expr(int lev) // 表示式分析(運算式) expression, 其中 lev 代表優先等級
{
  int t, *d;

  if (!tk) { printf("%d: unexpected eof in expression\n", line); exit(-1); } // EOF
  else if (tk == Num) { *++e = IMM; *++e = ival; next(); ty = INT; } // 取數為表達示數值
  else if (tk == '"') { // 字串
    *++e = IMM; *++e = ival; next();
    while (tk == '"') next();
    data = (char *)((int)data + sizeof(int) & -sizeof(int)); ty = PTR; // 用 int 為大小對齊 ??
  }
  else if (tk == Sizeof) { // 處理 sizeof(type) ，其中 type 可能為 char, int 或 ptr
    next(); if (tk == '(') next(); else { printf("%d: open paren expected in sizeof\n", line); exit(-1); }
    ty = INT; if (tk == Int) next(); else if (tk == Char) { next(); ty = CHAR; }
    while (tk == Mul) { next(); ty = ty + PTR; }//多级指標,每多一级加PTR
    if (tk == ')') next(); else { printf("%d: close paren expected in sizeof\n", line); exit(-1); }
    *++e = IMM; *++e = (ty == CHAR) ? sizeof(char) : sizeof(int);//除了char是一字節,int和多级指標都是int大小
    ty = INT;
  }
  else if (tk == Id) { // 處理 id ...
    d = id; next();
    if (tk == '(') { // id (args) ，這是 call
      next();
      t = 0;//形式参數
      while (tk != ')') { expr(Assign); *++e = PSH; ++t; if (tk == ',') next(); } // 推入 arg 計算形式参数的值且傳參數
      next();
      // d[Class] 可能為 Num = 128, Fun, Sys, Glo, Loc, ...
      if (d[Class] == Sys) *++e = d[Val]; // token 是系統呼叫 ???
      else if (d[Class] == Fun) { *++e = JSR; *++e = d[Val]; } // token 是自訂函數，用 JSR : jump to subroutine 指令呼叫
      else { printf("%d: bad function call\n", line); exit(-1); }
      if (t) { *++e = ADJ; *++e = t; } // 有參數，要調整堆疊  (ADJ : stack adjust)
      ty = d[Type];//函數返回值
    }
    else if (d[Class] == Num) { *++e = IMM; *++e = d[Val]; ty = INT; } // 該 id 是數值
    else {//變量先取地址然後再LC/LI(字元，整數載入ax)
      if (d[Class] == Loc) { *++e = LEA; *++e = loc - d[Val]; } // 該 id 是區域變數，載入區域變數 (LEA : load local address)區域變數位移
      else if (d[Class] == Glo) { *++e = IMM; *++e = d[Val]; }  // 該 id 是全域變數，載入該全域變數 (IMM : load global address or immediate 載入全域變數或立即值)全域變數位移
      else { printf("%d: undefined variable\n", line); exit(-1); }
      *++e = ((ty = d[Type]) == CHAR) ? LC : LI; // LI  : load int, LC  : load char
    }
  }
  else if (tk == '(') { // (E) : 有括號的運算式 ...
    next();
    if (tk == Int || tk == Char) {//強制類型轉換
      t = (tk == Int) ? INT : CHAR; next();
      while (tk == Mul) { next(); t = t + PTR; }
      if (tk == ')') next(); else { printf("%d: bad cast\n", line); exit(-1); }
      expr(Inc); // 處理 ++, -- 的情況 (優先級)
      ty = t;
    }
    else {//一般語法括號
      expr(Assign); // 處理 (E) 中的 E      (E 運算式必須能處理 (t=x) op y 的情況，所以用 expr(Assign))
      if (tk == ')') next(); else { printf("%d: close paren expected\n", line); exit(-1); }
    }
  }
  else if (tk == Mul) { // * 乘法
    next(); expr(Inc);//高優先级
    if (ty > INT) ty = ty - PTR; else { printf("%d: bad dereference\n", line); exit(-1); }
    *++e = (ty == CHAR) ? LC : LI;
  }
  else if (tk == And) { // & AND 取得地址
    next(); expr(Inc);
    if (*e == LC || *e == LI) --e; else { printf("%d: bad address-of\n", line); exit(-1); }//token為變量時都是先取地址再LI/LC,所以 e就變成了取地址到a
    ty = ty + PTR;
  }
  else if (tk == '!') { next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = 0; *++e = EQ; ty = INT; } // NOT !x等於 x==0
  else if (tk == '~') { next(); expr(Inc); *++e = PSH; *++e = IMM; *++e = -1; *++e = XOR; ty = INT; } // Logical NOT ~x等於 x ^ -1
  else if (tk == Add) { next(); expr(Inc); ty = INT; }
  else if (tk == Sub) {
    next(); *++e = IMM;
    if (tk == Num) { *++e = -ival; next(); } else { *++e = -1; *++e = PSH; expr(Inc); *++e = MUL; } // -Num or -E 乘以-1
    ty = INT;
  }
  else if (tk == Inc || tk == Dec) { // ++ or --  處理++x,--x//x--,x++在後面處理
    t = tk; next(); expr(Inc); //處理++x,--x
    if (*e == LC) { *e = PSH; *++e = LC; }//下面SC/SI用到,再取數
    else if (*e == LI) { *e = PSH; *++e = LI; }
    else { printf("%d: bad lvalue in pre-increment\n", line); exit(-1); }
    *++e = PSH;//將數值放入棧
    *++e = IMM; *++e = (ty > PTR) ? sizeof(int) : sizeof(char);//指標則加减一字,否則加減1
    *++e = (t == Inc) ? ADD : SUB;//運算
    *++e = (ty == CHAR) ? SC : SI;//存回變量
  }
  else { printf("%d: bad expression\n", line); exit(-1); }
  // 參考: https://en.wikipedia.org/wiki/Operator-precedence_parser, https://www.cnblogs.com/rubylouvre/archive/2012/09/08/2657682.html https://web.archive.org/web/20151223215421/http://hall.org.ua/halls/wizzard/pdf/Vaughan.Pratt.TDOP.pdf
  //tk為ASCII碼的都不会超過Num=128
  while (tk >= lev) { // "precedence climbing" or "Top Down Operator Precedence" method(優先爬升或自上而下的運算符優先級”方法)
    t = ty;//ty在遞迴過程中可能會被改變,所以備份當前處裡的表示式
    if (tk == Assign) {//賦值
      next();
      if (*e == LC || *e == LI) *e = PSH; else { printf("%d: bad lvalue in assignment\n", line); exit(-1); }//左邊被tk=Id中變量部分處理過,將地址傳入棧中
      expr(Assign); *++e = ((ty = t) == CHAR) ? SC : SI;//取得右值expr的值,作為a=expr的结果
    }
    else if (tk == Cond) {
      next();
      *++e = BZ; d = ++e;
      expr(Assign);
      if (tk == ':') next(); else { printf("%d: conditional missing colon\n", line); exit(-1); }
      *d = (int)(e + 3); *++e = JMP; d = ++e;
      expr(Cond);
      *d = (int)(e + 1);
    }
    else if (tk == Lor) { next(); *++e = BNZ; d = ++e; expr(Lan); *d = (int)(e + 1); ty = INT; }//短路,邏輯Or運算符左左邊true則表示式為true,不用計算運算符右側的值
    else if (tk == Lan) { next(); *++e = BZ;  d = ++e; expr(Or);  *d = (int)(e + 1); ty = INT; }//短路,邏輯And
    else if (tk == Or)  { next(); *++e = PSH; expr(Xor); *++e = OR;  ty = INT; }//將當前值Push,計算運算符右边值,再與當前值(在棧中)做運算;
    else if (tk == Xor) { next(); *++e = PSH; expr(And); *++e = XOR; ty = INT; }//expr中lev指明遞迴函数中最结合性不得低於哪一个運算符
    else if (tk == And) { next(); *++e = PSH; expr(Eq);  *++e = AND; ty = INT; }
    else if (tk == Eq)  { next(); *++e = PSH; expr(Lt);  *++e = EQ;  ty = INT; }
    else if (tk == Ne)  { next(); *++e = PSH; expr(Lt);  *++e = NE;  ty = INT; }
    else if (tk == Lt)  { next(); *++e = PSH; expr(Shl); *++e = LT;  ty = INT; }
    else if (tk == Gt)  { next(); *++e = PSH; expr(Shl); *++e = GT;  ty = INT; }
    else if (tk == Le)  { next(); *++e = PSH; expr(Shl); *++e = LE;  ty = INT; }
    else if (tk == Ge)  { next(); *++e = PSH; expr(Shl); *++e = GE;  ty = INT; }
    else if (tk == Shl) { next(); *++e = PSH; expr(Add); *++e = SHL; ty = INT; }
    else if (tk == Shr) { next(); *++e = PSH; expr(Add); *++e = SHR; ty = INT; }
    else if (tk == Add) {
      next(); *++e = PSH; expr(Mul);
      if ((ty = t) > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL;  }//處理指標
      *++e = ADD;
    }
    else if (tk == Sub) {
      next(); *++e = PSH; expr(Mul);
      if (t > PTR && t == ty) { *++e = SUB; *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = DIV; ty = INT; }//指標相減
      else if ((ty = t) > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL; *++e = SUB; }//指標減數值
      else *++e = SUB;
    }
    else if (tk == Mul) { next(); *++e = PSH; expr(Inc); *++e = MUL; ty = INT; }
    else if (tk == Div) { next(); *++e = PSH; expr(Inc); *++e = DIV; ty = INT; }
    else if (tk == Mod) { next(); *++e = PSH; expr(Inc); *++e = MOD; ty = INT; }
    else if (tk == Inc || tk == Dec) {//处理x++,x--
      if (*e == LC) { *e = PSH; *++e = LC; }
      else if (*e == LI) { *e = PSH; *++e = LI; }
      else { printf("%d: bad lvalue in post-increment\n", line); exit(-1); }
      *++e = PSH; *++e = IMM; *++e = (ty > PTR) ? sizeof(int) : sizeof(char);
      *++e = (tk == Inc) ? ADD : SUB;//先自增/自減
      *++e = (ty == CHAR) ? SC : SI;//存到内存里
      *++e = PSH; *++e = IMM; *++e = (ty > PTR) ? sizeof(int) : sizeof(char);
      *++e = (tk == Inc) ? SUB : ADD;//再相反操作,保證後自增/自減不影響這次表示式的求值
      next();
    }
    else if (tk == Brak) {//數組下標
      next(); *++e = PSH; expr(Assign);//保存數組指標, 計算下標
      if (tk == ']') next(); else { printf("%d: close bracket expected\n", line); exit(-1); }
      if (t > PTR) { *++e = PSH; *++e = IMM; *++e = sizeof(int); *++e = MUL;  }//t==PTR時是Char,Char = 0
      else if (t < PTR) { printf("%d: pointer type expected\n", line); exit(-1); }
      *++e = ADD;
      *++e = ((ty = t - PTR) == CHAR) ? LC : LI;
    }
    else { printf("%d: compiler error tk=%d\n", line, tk); exit(-1); }
  }
}

void stmt() // 陳述 statement
{
  int *a, *b;

  if (tk == If) { // if 語句
    next();
    if (tk == '(') next(); else { printf("%d: open paren expected\n", line); exit(-1); }
    expr(Assign);
    if (tk == ')') next(); else { printf("%d: close paren expected\n", line); exit(-1); }
    *++e = BZ; b = ++e;
    stmt();//繼續分析
    if (tk == Else) { // else 語句
      *b = (int)(e + 3);//e + 3 位置是else 起始位置
       *++e = JMP;// if 語句 else 之前插入 JMP 跳過Else 部分
        b = ++e;//JMP 的目標
      next();
      stmt();//分析else
    }
    *b = (int)(e + 1);//if 語句结束,無論是if BZ 轉跳目標還是 else 之前的JMP跳的目標
  }
  else if (tk == While) { // while 語句 (循環)
    next();
    a = e + 1;//循環開始的地址
    if (tk == '(') next(); else { printf("%d: open paren expected\n", line); exit(-1); }
    expr(Assign);
    if (tk == ')') next(); else { printf("%d: close paren expected\n", line); exit(-1); }
    *++e = BZ; b = ++e;// b = While 語句結束後的地址
    stmt();//處理While 語句
    *++e = JMP; *++e = (int)a;//無條件轉跳到While語句开始(包函循環條件的代碼),實現循環
    *b = (int)(e + 1);//BZ轉跳目標(循環结束)
  }
  else if (tk == Return) { // return 語句
    next();
    if (tk != ';') expr(Assign);//計算返回值
    *++e = LEV;
    if (tk == ';') next(); else { printf("%d: semicolon expected\n", line); exit(-1); }
  }
  else if (tk == '{') { // 區塊 {...} 複合語句
    next();
    while (tk != '}') stmt();
    next();
  }
  else if (tk == ';') { // ; 空陳述
    next();
  }
  else { // 指定 assign
    expr(Assign);//一般的語句視為賦值語句 或者 表示式
    if (tk == ';') next(); else { printf("%d: semicolon expected\n", line); exit(-1); }
  }
}

int prog() { // 編譯整個程式 Program
  int bt, i;
  line = 1;
  next();
  while (tk) {
    bt = INT; // basetype
    if (tk == Int) next();//已經有bt == INT
    else if (tk == Char) { next(); bt = CHAR; }//char 變量
    else if (tk == Enum) { // enum Id? {... 列舉
      next();
      if (tk != '{') next(); // 略過 Id
      if (tk == '{') {
        next();
        i = 0; // 紀錄 enum 的目前值 默認重0開始
        while (tk != '}') {
          if (tk != Id) { printf("%d: bad enum identifier %d\n", line, tk); return -1; }
          next();
          if (tk == Assign) { // 有 Id=Num 的情況 賦值語句
            next();
            if (tk != Num) { printf("%d: bad enum initializer\n", line); return -1; }
            i = ival;
            next();
          } //id 已經由 next 函數處理過
          id[Class] = Num; id[Type] = INT; id[Val] = i++;
          if (tk == ',') next();
        }
        next();
      }
    }//Enum 處理玩tk == ';', 略過下面
    while (tk != ';' && tk != '}') { // 掃描直到區塊結束
      ty = bt;
      while (tk == Mul) { next(); ty = ty + PTR; }// tk == Mul 表示已*開頭,為指標類型,類型加PTR表示何整類型的指標
      if (tk != Id) { printf("%d: bad global declaration\n", line); return -1; }
      if (id[Class]) { printf("%d: duplicate global definition\n", line); return -1; } // id.Class 已經存在，重複宣告了！
      next();
      id[Type] = ty;//賦值類型
      if (tk == '(') { // function 函數定義 ex: int f( ...
        id[Class] = Fun;
        id[Val] = (int)(e + 1);
        next(); i = 0;
        while (tk != ')') { // 掃描參數直到 ...)
          ty = INT;
          if (tk == Int) next();
          else if (tk == Char) { next(); ty = CHAR; }
          while (tk == Mul) { next(); ty = ty + PTR; }
          if (tk != Id) { printf("%d: bad parameter declaration\n", line); return -1; }
          if (id[Class] == Loc) { printf("%d: duplicate parameter definition\n", line); return -1; } // 這裡的 id 會指向 hash 搜尋過的 symTable 裏的那個 (在 next 裏處理的)，所以若是該 id 已經是 Local，那麼就重複了！
          // 把 id.Class, id.Type, id.Val 暫存到 id.HClass, id.HType, id.Hval ，因為 Local 優先於 Global
          id[HClass] = id[Class]; id[Class] = Loc;
          id[HType]  = id[Type];  id[Type] = ty;
          id[HVal]   = id[Val];   id[Val] = i++;//區域變量編號
          next();
          if (tk == ',') next();
        }
        next();
        if (tk != '{') { printf("%d: bad function definition\n", line); return -1; } // BODY 開始 {...
        loc = ++i;//區域變量偏移值
        next();
        while (tk == Int || tk == Char) { // 宣告 函數內變量
          bt = (tk == Int) ? INT : CHAR;
          next();
          while (tk != ';') {
            ty = bt;
            while (tk == Mul) { next(); ty = ty + PTR; }//處理指標
            if (tk != Id) { printf("%d: bad local declaration\n", line); return -1; }
            if (id[Class] == Loc) { printf("%d: duplicate local definition\n", line); return -1; }//備份符號訊息
            // 把 id.Class, id.Type, id.Val 暫存到 id.HClass, id.HType, id.Hval ，因為 Local 優先於 Global
            id[HClass] = id[Class]; id[Class] = Loc;
            id[HType]  = id[Type];  id[Type] = ty;
            id[HVal]   = id[Val];   id[Val] = ++i;//儲存變量偏移值
            next();
            if (tk == ',') next();
          }
          next();
        }
        *++e = ENT; *++e = i - loc;//函數區域變量數目
        while (tk != '}') stmt();//語法分析
        *++e = LEV;//函數返回
        id = sym; // unwind symbol table locals (把被區域變數隱藏掉的那些 Local id 還原，恢復全域變數的符號定義)
        while (id[Tk]) {//恢復符號訊息
          if (id[Class] == Loc) {
            id[Class] = id[HClass];
            id[Type] = id[HType];
            id[Val] = id[HVal];
          }
          id = id + Idsz;
        }
      }
      else {
        id[Class] = Glo;//全域變量
        id[Val] = (int)data;//全域變量在資料段分配內存
        data = data + sizeof(int);
      }
      if (tk == ',') next();
    }
    next();
  }
  return 0;
}

int run(int *pc, int *bp, int *sp) { // 虛擬機 => pc: 程式計數器, sp: 堆疊暫存器, bp: 框架暫存器
  int a, cycle; // a: 累積器, cycle: 執行指令數
  int i, *t;    // i: instruction, t:temps

  cycle = 0;
  while (1) {
    i = *pc++; ++cycle;
    if (debug) {
      printf("%d> %.4s", cycle,
        &"LEA ,IMM ,JMP ,JSR ,BZ  ,BNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PSH ,"
         "OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,"
         "OPEN,READ,CLOS,PRTF,MALC,FREE,MSET,MCMP,EXIT,"[i * 5]);
      if (i <= ADJ) printf(" %d\n", *pc); else printf("\n");
    }
    if      (i == LEA) a = (int)(bp + *pc++);                             // load local address 載入區域變數
    else if (i == IMM) a = *pc++;                                         // load global address or immediate 載入全域變數或立即值
    else if (i == JMP) pc = (int *)*pc;                                   // jump               躍躍指令
    else if (i == JSR) { *--sp = (int)(pc + 1); pc = (int *)*pc; }        // jump to subroutine 跳到副程式
    else if (i == BZ)  pc = a ? pc + 1 : (int *)*pc;                      // branch if zero     if (a==0) goto m[pc]
    else if (i == BNZ) pc = a ? (int *)*pc : pc + 1;                      // branch if not zero if (a!=0) goto m[pc]
    else if (i == ENT) { *--sp = (int)bp; bp = sp; sp = sp - *pc++; }     // enter subroutine   進入副程式
    else if (i == ADJ) sp = sp + *pc++;                                   // stack adjust       調整堆疊
    else if (i == LEV) { sp = bp; bp = (int *)*sp++; pc = (int *)*sp++; } // leave subroutine   離開副程式
    else if (i == LI)  a = *(int *)a;                                     // load int           載入整數
    else if (i == LC)  a = *(char *)a;                                    // load char          載入字元
    else if (i == SI)  *(int *)*sp++ = a;                                 // store int          儲存整數
    else if (i == SC)  a = *(char *)*sp++ = a;                            // store char         儲存字元
    else if (i == PSH) *--sp = a;                                         // push               推入堆疊

    else if (i == OR)  a = *sp++ |  a; // a = a OR *sp
    else if (i == XOR) a = *sp++ ^  a; // a = a XOR *sp
    else if (i == AND) a = *sp++ &  a; // ...
    else if (i == EQ)  a = *sp++ == a;
    else if (i == NE)  a = *sp++ != a;
    else if (i == LT)  a = *sp++ <  a;
    else if (i == GT)  a = *sp++ >  a;
    else if (i == LE)  a = *sp++ <= a;
    else if (i == GE)  a = *sp++ >= a;
    else if (i == SHL) a = *sp++ << a;
    else if (i == SHR) a = *sp++ >> a;
    else if (i == ADD) a = *sp++ +  a;
    else if (i == SUB) a = *sp++ -  a;
    else if (i == MUL) a = *sp++ *  a;
    else if (i == DIV) a = *sp++ /  a;
    else if (i == MOD) a = *sp++ %  a;

    else if (i == OPEN) a = open((char *)sp[1], *sp); // 開檔
    else if (i == READ) a = read(sp[2], (char *)sp[1], *sp); // 讀檔
    else if (i == CLOS) a = close(*sp); // 關檔
    else if (i == PRTF) { t = sp + pc[1]; a = printf((char *)t[-1], t[-2], t[-3], t[-4], t[-5], t[-6]); } // printf("....", a, b, c, d, e)
    else if (i == MALC) a = (int)malloc(*sp); // 分配記憶體
    else if (i == FREE) free((void *)*sp); // 釋放記憶體
    else if (i == MSET) a = (int)memset((char *)sp[2], sp[1], *sp); // 設定記憶體
    else if (i == MCMP) a = memcmp((char *)sp[2], (char *)sp[1], *sp); // 比較記憶體
    else if (i == EXIT) { printf("exit(%d) cycle = %d\n", *sp, cycle); return *sp; } // EXIT 離開
    else { printf("unknown instruction = %d! cycle = %d\n", i, cycle); return -1; } // 錯誤處理
  }
}

int main(int argc, char **argv) // 主程式
{
  int fd, ty, poolsz, *idmain;
  int *pc, *bp, *sp;
  int i, *t;

  --argc; ++argv;
  if (argc > 0 && **argv == '-' && (*argv)[1] == 's') { src = 1; --argc; ++argv; }
  if (argc > 0 && **argv == '-' && (*argv)[1] == 'd') { debug = 1; --argc; ++argv; }
  if (argc < 1) { printf("usage: c4 [-s] [-d] file ...\n"); return -1; }

  if ((fd = open(*argv, 0)) < 0) { printf("could not open(%s)\n", *argv); return -1; }

  poolsz = 256*1024; // arbitrary size
  if (!(sym = malloc(poolsz))) { printf("could not malloc(%d) symbol area\n", poolsz); return -1; } // 符號段
  if (!(le = e = malloc(poolsz))) { printf("could not malloc(%d) text area\n", poolsz); return -1; } // 程式段
  if (!(data = malloc(poolsz))) { printf("could not malloc(%d) data area\n", poolsz); return -1; } // 資料段
  if (!(sp = malloc(poolsz))) { printf("could not malloc(%d) stack area\n", poolsz); return -1; }  // 堆疊段

  memset(sym,  0, poolsz);
  memset(e,    0, poolsz);
  memset(data, 0, poolsz);

  p = "char else enum if int return sizeof while "
      "open read close printf malloc free memset memcmp exit void main";
  i = Char; while (i <= While) { next(); id[Tk] = i++; } // add keywords to symbol table
  i = OPEN; while (i <= EXIT) { next(); id[Class] = Sys; id[Type] = INT; id[Val] = i++; } // add library to symbol table
  next(); id[Tk] = Char; // handle void type
  next(); idmain = id; // keep track of main

  if (!(lp = p = malloc(poolsz))) { printf("could not malloc(%d) source area\n", poolsz); return -1; }
  if ((i = read(fd, p, poolsz-1)) <= 0) { printf("read() returned %d\n", i); return -1; }
  p[i] = 0; // 設定程式 p 字串結束符號 \0
  close(fd);

  if (prog() == -1) return -1;

  if (!(pc = (int *)idmain[Val])) { printf("main() not defined\n"); return -1; }
  if (src) return 0;

  // setup stack
  bp = sp = (int *)((int)sp + poolsz);
  *--sp = EXIT; // call exit if main returns
  *--sp = PSH; t = sp;
  *--sp = argc;
  *--sp = (int)argv;
  *--sp = (int)t;
  return run(pc, bp, sp);
}
```

## 參考資料
* [手把手教你做一個 C 語言編譯器（0）：前言](https://www.itread01.com/content/1546074209.html)
* [手把手教你做一個 C 語言編譯器（1）：設計](https://www.itread01.com/content/1546074380.html)
* [手把手教你做一個 C 語言編譯器（2）：虛擬機器](https://www.itread01.com/content/1546071510.html)
* [手把手教你构建 C 语言编译器（3）- 词法分析器](https://lotabout.me/2015/write-a-C-interpreter-3/)
* [手把手教你做一個 C 語言編譯器（4）：遞迴下降](https://www.itread01.com/content/1546073118.html)
* [手把手教你做一個 C 語言編譯器（5）：變數定義](https://www.itread01.com/content/1546075093.html)
* [手把手教你做一個 C 語言編譯器（6）：函式定義 ](https://www.itread01.com/content/1546072214.html)
* [手把手教你做一個 C 語言編譯器（7）：語句](https://www.itread01.com/content/1545510448.html)
* [手把手教你做一個 C 語言編譯器（8）：表示式](https://www.itread01.com/content/1545510446.html)
* [手把手教你做一個 C 語言編譯器（9）：總結](https://www.itread01.com/content/1545510449.html)
* [陳鍾誠老師 sp/C1-c4](https://gitlab.com/ccc109/sp/-/tree/master/C1-c4)

